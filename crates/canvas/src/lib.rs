pub mod shaders;

use vek::{Extent2, Rect, Rgba, Vec2};

/// Trait that defines a pixel of a canvas.
pub trait Pixel: Default {
    /// Blends `self` on top of `other`.
    ///
    /// If `self` is opaque, the result equals `self`.
    /// If `self` is transparent, the result equals `other`.
    /// If `self` is translucent, it interpolates opaque `self` and `other`
    /// according to `self`'s opacity.
    ///
    /// This operation is non-commutative.
    fn blend_normal(&self, other: &Self) -> Self;
}

/// Trait that defines a canvas that can be drawn to.
pub trait Canvas {
    type Pixel;

    /// Places a single pixel within the frame buffer.
    fn put_pixel(&mut self, position: Vec2<usize>, pixel: Self::Pixel);

    /// Draws a rectangle with a single colour.
    fn rect(&mut self, rect: Rect<usize, usize>, color: Self::Pixel)
    where
        Self::Pixel: Clone;

    /// Clears the canvas.
    fn clear(&mut self);

    /// Draws a quad with an image generated by a 'shader'.
    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    );

    /// Resizes the canvas to `new_size`;
    fn resize(&mut self, new_size: Extent2<usize>)
    where
        Self::Pixel: Clone;
}

pub struct PixelShaderInput {
    pub uv: Vec2<f32>,
    pub pixel_coord: Vec2<u32>,
    pub time: f32,
}

/// A unit of the beautiful frame buffer.
#[derive(Copy, Clone, PartialEq)]
pub struct TextModePixel {
    pub bg_color: Rgba<f32>,
    pub fg_color: Rgba<f32>,
    pub character: char,
}

impl Default for TextModePixel {
    fn default() -> Self {
        Self {
            bg_color: Rgba::new_transparent(0.0, 0.0, 0.0),
            fg_color: Rgba::new_transparent(0.0, 0.0, 0.0),
            character: ' ',
        }
    }
}

impl TextModePixel {
    pub fn new(
        bg_color: Rgba<f32>,
        fg_color: Rgba<f32>,
        character: char,
    ) -> Self {
        Self {
            bg_color,
            fg_color,
            character,
        }
    }
}

impl Pixel for TextModePixel {
    fn blend_normal(&self, under_pixel: &Self) -> Self {
        fn lerp(a: Rgba<f32>, b: Rgba<f32>, factor: f32) -> Rgba<f32> {
            a * (1.0 - factor) + b * factor
        }

        // This simulates looking at the under pixel through the top pixel as if it were translucent.
        let bg_color =
            lerp(under_pixel.bg_color, self.bg_color, self.bg_color.a);

        let (character, fg_color) = if self.character == ' ' {
            // If this pixel has no character, we just show the character underneath,
            // but tinted with our pixel's background colour.
            (
                under_pixel.character,
                lerp(under_pixel.fg_color, self.bg_color, self.bg_color.a),
            )
        } else {
            // Unless we show our own character.
            (
                self.character,
                lerp(bg_color, self.fg_color, self.fg_color.a),
            )
        };

        TextModePixel {
            bg_color,
            fg_color,
            character,
        }
    }
}

pub struct PixelCanvas<P> {
    pub size: Extent2<usize>,
    pub back_buffer: Vec<P>,
    pub front_buffer: Vec<P>,
    pub needs_full_redraw: bool,
}

impl<P> PixelCanvas<P>
where
    P: Pixel + Clone,
{
    pub fn new(size: Extent2<usize>) -> Self {
        PixelCanvas {
            size,
            back_buffer: vec![P::default(); size.w * size.h],
            front_buffer: vec![P::default(); size.w * size.h],
            needs_full_redraw: true,
        }
    }
}

impl<P> Canvas for PixelCanvas<P>
where
    P: Pixel + Clone + Default,
{
    type Pixel = P;

    fn put_pixel(&mut self, position: Vec2<usize>, new_pixel: P) {
        if position.x < self.size.w
            && position.y < self.size.h
            && let Some(pixel) = self
                .back_buffer
                .get_mut(position.y * self.size.w + position.x)
        {
            *pixel = new_pixel.blend_normal(pixel);
        }
    }

    fn rect(&mut self, rect: Rect<usize, usize>, color: Self::Pixel) {
        for y in rect.y..(rect.y + rect.h) {
            for x in rect.x..(rect.x + rect.w) {
                // DEBUG: Draw hollow rectangles instead.
                // if !(x == rect.x
                //     || x == rect.x + rect.w - 1
                //     || y == rect.y
                //     || y == rect.y + rect.h - 1)
                // {
                //     continue;
                // }

                self.put_pixel(Vec2::new(x, y), color.clone());
            }
        }
    }

    fn clear(&mut self) {
        self.back_buffer.fill(P::default());
    }

    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    ) {
        let x_start = rect.x.floor() as usize;
        let y_start = rect.y.floor() as usize;
        let x_end = (rect.x + rect.w).floor() as usize;
        let y_end = (rect.y + rect.h).floor() as usize;

        for y in y_start..y_end {
            for x in x_start..x_end {
                let u = (x as f32 - rect.x) / rect.w;
                let v = (y as f32 - rect.y) / rect.h;

                let input = PixelShaderInput {
                    uv: Vec2::new(u, v),
                    pixel_coord: Vec2::new(x as u32, y as u32),
                    time: 0.0,
                };
                self.put_pixel(Vec2::new(x, y), shader(input));
            }
        }
    }

    fn resize(&mut self, new_size: Extent2<usize>) {
        let new_buffer_size = new_size.w * new_size.h;
        if self.back_buffer.len() > new_buffer_size {
            self.back_buffer.truncate(new_buffer_size);
            self.front_buffer.truncate(new_buffer_size);
        } else {
            self.back_buffer.resize(new_buffer_size, P::default());
            self.front_buffer.resize(new_buffer_size, P::default());
        }
        self.back_buffer.fill(P::default());
        self.front_buffer.fill(P::default());
        self.size = new_size;
        self.needs_full_redraw = true;
    }
}
