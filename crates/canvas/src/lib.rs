use ui_composer_math::prelude::{Point2, Rect, Size2, Srgba, Vector2};

pub mod shaders;

/// Trait that defines a pixel of a canvas.
pub trait Pixel: Default {
    /// Blends `self` on top of `other`.
    ///
    /// If `self` is opaque, the result equals `self`.
    /// If `self` is transparent, the result equals `other`.
    /// If `self` is translucent, it interpolates opaque `self` and `other`
    /// according to `self`'s opacity.
    ///
    /// This operation is non-commutative.
    fn blend_normal(&self, other: &Self) -> Self;
}

/// Trait that defines a canvas that can be drawn to.
pub trait Canvas {
    type Pixel;

    /// Places a single pixel within the frame buffer.
    fn put_pixel(&mut self, position: Point2<u32>, pixel: Self::Pixel);

    /// Draws a rectangle with a single colour.
    fn rect(&mut self, rect: Rect<u32>, color: Self::Pixel)
    where
        Self::Pixel: Clone;

    /// Clears the canvas.
    fn clear(&mut self);

    /// Draws a quad with an image generated by a 'shader'.
    fn quad(
        &mut self,
        rect: Rect<u32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    );

    /// Resizes the canvas to `new_size`;
    fn resize(&mut self, new_size: Size2<u32>)
    where
        Self::Pixel: Clone;
}

pub struct PixelShaderInput {
    pub uv: Point2,
    pub pixel_coord: Point2<u32>,
    pub time: f32,
}

/// A unit of the beautiful frame buffer.
#[derive(Copy, Clone, PartialEq)]
pub struct TextModePixel {
    pub bg_color: Srgba,
    pub fg_color: Srgba,
    pub character: char,
}

impl Default for TextModePixel {
    fn default() -> Self {
        Self {
            bg_color: Srgba::new(0.0, 0.0, 0.0, 0.0),
            fg_color: Srgba::new(0.0, 0.0, 0.0, 0.0),
            character: ' ',
        }
    }
}

impl TextModePixel {
    pub fn new(bg_color: Srgba, fg_color: Srgba, character: char) -> Self {
        Self {
            bg_color,
            fg_color,
            character,
        }
    }
}

impl Pixel for TextModePixel {
    fn blend_normal(&self, under_pixel: &Self) -> Self {
        fn lerp(a: Srgba, b: Srgba, factor: f32) -> Srgba {
            a * (1.0 - factor) + b * factor
        }

        // This simulates looking at the under pixel through the top pixel as if it were translucent.
        let bg_color =
            lerp(under_pixel.bg_color, self.bg_color, self.bg_color.alpha);

        let (character, fg_color) = if self.character == ' ' {
            // If this pixel has no character, we just show the character underneath,
            // but tinted with our pixel's background colour.
            (
                under_pixel.character,
                lerp(under_pixel.fg_color, self.bg_color, self.bg_color.alpha),
            )
        } else {
            // Unless we show our own character.
            (
                self.character,
                lerp(bg_color, self.fg_color, self.fg_color.alpha),
            )
        };

        TextModePixel {
            bg_color,
            fg_color,
            character,
        }
    }
}

pub struct PixelCanvas<P> {
    pub size: Size2<u32>,
    pub back_buffer: Vec<P>,
    pub front_buffer: Vec<P>,
    pub needs_full_redraw: bool,
}

impl<P> PixelCanvas<P>
where
    P: Pixel + Clone,
{
    pub fn new(size: Size2<u32>) -> Self {
        PixelCanvas {
            size,
            back_buffer: vec![
                P::default();
                (size.width * size.height) as usize
            ],
            front_buffer: vec![
                P::default();
                (size.width * size.height) as usize
            ],
            needs_full_redraw: true,
        }
    }
}

impl<P> Canvas for PixelCanvas<P>
where
    P: Pixel + Clone + Default,
{
    type Pixel = P;

    fn put_pixel(&mut self, position: Point2<u32>, new_pixel: P) {
        if position.x < self.size.width
            && position.y < self.size.height
            && let Some(pixel) = self
                .back_buffer
                .get_mut((position.y * self.size.width + position.x) as usize)
        {
            *pixel = new_pixel.blend_normal(pixel);
        }
    }

    fn rect(&mut self, rect: Rect<u32>, color: Self::Pixel) {
        let rect = rect.to_box2();

        for y in rect.min.y..rect.max.y {
            for x in rect.min.x..rect.max.x {
                // DEBUG: Draw hollow rectangles instead.
                // if !(x == rect.origin.x
                //     || x == rect.origin.x + rect.size.width - 1
                //     || y == rect.origin.y
                //     || y == rect.origin.y + rect.size.height - 1)
                // {
                //     continue;
                // }

                self.put_pixel(Point2::new(x, y), color.clone());
            }
        }
    }

    fn clear(&mut self) {
        self.back_buffer.fill(P::default());
    }

    fn quad(
        &mut self,
        rect: Rect<u32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    ) {
        let aabb = rect.to_box2();

        for y in aabb.min.y..aabb.max.y {
            for x in aabb.min.x..aabb.max.x {
                let uv = (Vector2::<f32>::new(
                    (x - rect.origin.x) as f32,
                    (y - rect.origin.y) as f32,
                )) / rect.size.as_::<f32>().to_vector();

                let input = PixelShaderInput {
                    uv: uv.to_point(),
                    pixel_coord: Point2::new(x, y),
                    time: 0.0,
                };
                self.put_pixel(Point2::new(x, y), shader(input));
            }
        }
    }

    fn resize(&mut self, new_size: Size2<u32>) {
        let new_buffer_size = new_size.area() as usize;
        if self.back_buffer.len() > new_buffer_size {
            self.back_buffer.truncate(new_buffer_size);
            self.front_buffer.truncate(new_buffer_size);
        } else {
            self.back_buffer.resize(new_buffer_size, P::default());
            self.front_buffer.resize(new_buffer_size, P::default());
        }
        self.back_buffer.fill(P::default());
        self.front_buffer.fill(P::default());
        self.size = new_size;
        self.needs_full_redraw = true;
    }
}
