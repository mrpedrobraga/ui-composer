use crate::runners::tui::render::shaders::PixelShaderInput;
use crossterm::QueueableCommand;
use crossterm::cursor::MoveTo;
use crossterm::style::{Color, PrintStyledContent, Stylize};
use ndarray::Array2;
use std::io::{Write, stdout};
use vek::{Rect, Rgba, Vec2};

/// Trait that defines a pixel of a canvas.
pub trait Pixel: Default {
    /// Blends `self` on top of `other`.
    ///
    /// If `self` is opaque, the result equals `self`.
    /// If `self` is transparent, the result equals `other`.
    /// If `self` is translucent, it interpolates opaque `self` and `other`
    /// according to `self`'s opacity.
    ///
    /// This operation is non-commutative.
    fn blend_normal(&self, other: Self) -> Self;
}

/// Trait that defines a canvas that can be drawn to.
pub trait Canvas {
    type Pixel;

    /// Places a single pixel within the frame buffer.
    fn put_pixel(&mut self, position: Vec2<u32>, pixel: Self::Pixel);

    /// Draws a rectangle with a single colour.
    fn rect(&mut self, rect: Rect<u32, u32>, color: Self::Pixel)
    where
        Self::Pixel: Clone;

    /// Clears the canvas.
    fn clear(&mut self);

    /// Draws a quad with an image generated by a 'shader'.
    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    );
}

/// A unit of the beautiful frame buffer.
#[derive(Copy, Clone, PartialEq)]
pub struct TextModePixel {
    bg_color: Rgba<f32>,
    fg_color: Rgba<f32>,
    character: char,
}

impl Default for TextModePixel {
    fn default() -> Self {
        Self {
            bg_color: Rgba::black(),
            fg_color: Rgba::black(),
            character: ' ',
        }
    }
}

impl TextModePixel {
    pub fn new(
        bg_color: Rgba<f32>,
        fg_color: Rgba<f32>,
        character: char,
    ) -> Self {
        Self {
            bg_color,
            fg_color,
            character,
        }
    }
}

impl Pixel for TextModePixel {
    fn blend_normal(&self, other: Self) -> Self {
        /// Interpolates linearly between A and B.
        fn lerp(a: Rgba<f32>, b: Rgba<f32>, factor: f32) -> Rgba<f32> {
            a * (factor) + b * (1.0 - factor)
        }

        let self_bg_color_opaque =
            Rgba::new(self.bg_color.r, self.bg_color.g, self.bg_color.b, 1.0);

        // The background colour is just the NORMAL blend of the background colours.
        let bg_color =
            lerp(other.bg_color, self_bg_color_opaque, self.bg_color.a);

        let (fg_color, character) = if self.character == ' ' {
            (
                // The bottom pixel will have its character partially "occluded" by
                // the top pixel's background.
                lerp(other.fg_color, self_bg_color_opaque, self.bg_color.a),
                other.character,
            )
        } else {
            // The top pixel's character can not be occluded.
            // If it has any alpha, that won't be resolved right now,
            // it will be resolved when drawing to the canvas...
            (self.fg_color, self.character)
        };

        TextModePixel {
            bg_color,
            fg_color,
            character,
        }
    }
}

pub struct PixelCanvas<P> {
    pixels: Array2<P>,
}

impl<P> PixelCanvas<P>
where
    P: Pixel,
{
    pub fn new(size: vek::Extent2<usize>) -> Self {
        PixelCanvas {
            pixels: Array2::default([size.w, size.h]),
        }
    }
}

impl PixelCanvas<TextModePixel> {
    pub fn show(&self) {
        let mut s = stdout();

        for ((x, y), pixel) in self.pixels.indexed_iter() {
            s.queue(MoveTo(x as u16, y as u16)).unwrap();

            fn f32tou8(x: f32) -> u8 {
                (x * 255.0) as u8
            }

            s.queue(PrintStyledContent(
                pixel
                    .character
                    .with(Color::Rgb {
                        r: f32tou8(pixel.fg_color.r),
                        g: f32tou8(pixel.fg_color.g),
                        b: f32tou8(pixel.fg_color.b),
                    })
                    .on(Color::Rgb {
                        r: f32tou8(pixel.bg_color.r),
                        g: f32tou8(pixel.bg_color.g),
                        b: f32tou8(pixel.bg_color.b),
                    }),
            ))
            .unwrap();
        }

        s.flush().unwrap();
    }
}

impl<P> Canvas for PixelCanvas<P>
where
    P: Default,
{
    type Pixel = P;

    fn put_pixel(&mut self, position: Vec2<u32>, pixel: P) {
        self.pixels[(position.x as usize, position.y as usize)] = pixel;
    }

    fn rect(&mut self, rect: Rect<u32, u32>, color: Self::Pixel)
    where
        Self::Pixel: Clone,
    {
        let x0 = rect.x;
        let x1 = rect.x + rect.w;
        let y0 = rect.y;
        let y1 = rect.y + rect.h;

        for y in y0..y1 {
            for x in x0..x1 {
                self.put_pixel(Vec2::new(x, y), color.clone());
            }
        }
    }

    fn clear(&mut self) {
        for pixel in &mut self.pixels {
            *pixel = P::default();
        }
    }

    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    ) {
        let x0 = rect.x.floor();
        let x1 = rect.x.floor() + rect.w.floor();
        let y0 = rect.y.floor();
        let y1 = rect.y.floor() + rect.h.floor();

        for y in y0 as u32..y1 as u32 {
            for x in x0 as u32..x1 as u32 {
                let u = (x as f32 - x0) / (x1 - x0);
                let v = (y as f32 - y0) / (y1 - y0);

                let input = PixelShaderInput {
                    uv: Vec2::new(u, v),
                    pixelCoord: Vec2::new(x, y),
                    time: 0.0,
                };
                self.put_pixel(Vec2::new(x, y), shader(input));
            }
        }
    }
}
