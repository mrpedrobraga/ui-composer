use crate::runners::tui::render::shaders::PixelShaderInput;
use crossterm::QueueableCommand;
use crossterm::cursor::MoveTo;
use crossterm::style::{Color, PrintStyledContent, Stylize};
use std::io::{Write, stdout};
use vek::{Extent2, Rect, Rgba, Vec2};

/// Trait that defines a pixel of a canvas.
pub trait Pixel: Default {
    /// Blends `self` on top of `other`.
    ///
    /// If `self` is opaque, the result equals `self`.
    /// If `self` is transparent, the result equals `other`.
    /// If `self` is translucent, it interpolates opaque `self` and `other`
    /// according to `self`'s opacity.
    ///
    /// This operation is non-commutative.
    fn blend_normal(&self, other: Self) -> Self;
}

/// Trait that defines a canvas that can be drawn to.
pub trait Canvas {
    type Pixel;

    /// Places a single pixel within the frame buffer.
    fn put_pixel(&mut self, position: Vec2<usize>, pixel: Self::Pixel);

    /// Draws a rectangle with a single colour.
    fn rect(&mut self, rect: Rect<usize, usize>, color: Self::Pixel)
    where
        Self::Pixel: Clone;

    /// Clears the canvas.
    fn clear(&mut self);

    /// Draws a quad with an image generated by a 'shader'.
    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    );

    /// Resizes the canvas to `new_size`;
    fn resize(&mut self, new_size: Extent2<usize>)
    where
        Self::Pixel: Clone;
}

/// A unit of the beautiful frame buffer.
#[derive(Copy, Clone, PartialEq)]
pub struct TextModePixel {
    pub bg_color: Rgba<f32>,
    pub fg_color: Rgba<f32>,
    pub character: char,
}

impl Default for TextModePixel {
    fn default() -> Self {
        Self {
            bg_color: Rgba::black(),
            fg_color: Rgba::black(),
            character: ' ',
        }
    }
}

impl TextModePixel {
    pub fn new(
        bg_color: Rgba<f32>,
        fg_color: Rgba<f32>,
        character: char,
    ) -> Self {
        Self {
            bg_color,
            fg_color,
            character,
        }
    }
}

impl Pixel for TextModePixel {
    fn blend_normal(&self, other: Self) -> Self {
        /// Interpolates linearly between A and B.
        fn lerp(a: Rgba<f32>, b: Rgba<f32>, factor: f32) -> Rgba<f32> {
            a * (factor) + b * (1.0 - factor)
        }

        let self_bg_color_opaque =
            Rgba::new(self.bg_color.r, self.bg_color.g, self.bg_color.b, 1.0);

        // The background colour is just the NORMAL blend of the background colours.
        let bg_color =
            lerp(other.bg_color, self_bg_color_opaque, self.bg_color.a);

        let (fg_color, character) = if self.character == ' ' {
            (
                // The bottom pixel will have its character partially "occluded" by
                // the top pixel's background.
                lerp(other.fg_color, self_bg_color_opaque, self.bg_color.a),
                other.character,
            )
        } else {
            // The top pixel's character can not be occluded.
            // If it has any alpha, that won't be resolved right now,
            // it will be resolved when drawing to the canvas...
            (self.fg_color, self.character)
        };

        TextModePixel {
            bg_color,
            fg_color,
            character,
        }
    }
}

pub struct PixelCanvas<P> {
    size: Extent2<usize>,
    pixels: Vec<P>,
}

impl<P> PixelCanvas<P>
where
    P: Pixel + Clone,
{
    pub fn new(size: Extent2<usize>) -> Self {
        PixelCanvas {
            size,
            pixels: vec![P::default(); size.w * size.h],
        }
    }
}

impl PixelCanvas<TextModePixel> {
    pub fn show(&self) {
        let mut s = stdout();

        fn f32tou8(x: f32) -> u8 {
            (x.clamp(0.0, 1.0) * 255.0) as u8
        }

        for y in 0..self.size.h {
            for x in 0..self.size.w {
                if let Some(pixel) = self.pixels.get(y * self.size.w + x) {
                    s.queue(MoveTo(x as u16, y as u16)).unwrap();
                    s.queue(PrintStyledContent(
                        pixel
                            .character
                            .with(Color::Rgb {
                                r: f32tou8(pixel.fg_color.r),
                                g: f32tou8(pixel.fg_color.g),
                                b: f32tou8(pixel.fg_color.b),
                            })
                            .on(Color::Rgb {
                                r: f32tou8(pixel.bg_color.r),
                                g: f32tou8(pixel.bg_color.g),
                                b: f32tou8(pixel.bg_color.b),
                            }),
                    ))
                    .unwrap();
                }
            }
        }
    }
}

impl<P> Canvas for PixelCanvas<P>
where
    P: Pixel + Clone + Default,
{
    type Pixel = P;

    fn put_pixel(&mut self, position: Vec2<usize>, new_pixel: P) {
        if position.x < self.size.w
            && position.y < self.size.h
            && let Some(pixel) =
                self.pixels.get_mut(position.y * self.size.w + position.x)
        {
            *pixel = new_pixel;
        }
    }

    fn rect(&mut self, rect: Rect<usize, usize>, color: Self::Pixel) {
        for y in rect.y..(rect.y + rect.h) {
            for x in rect.x..(rect.x + rect.w) {
                self.put_pixel(Vec2::new(x, y), color.clone());
            }
        }
    }

    fn clear(&mut self) {
        self.pixels.fill(P::default());
    }

    fn quad(
        &mut self,
        rect: Rect<f32, f32>,
        shader: impl Fn(PixelShaderInput) -> Self::Pixel,
    ) {
        let x_start = rect.x.floor() as usize;
        let y_start = rect.y.floor() as usize;
        let x_end = (rect.x + rect.w).floor() as usize;
        let y_end = (rect.y + rect.h).floor() as usize;

        for y in y_start..y_end {
            for x in x_start..x_end {
                let u = (x as f32 - rect.x) / rect.w;
                let v = (y as f32 - rect.y) / rect.h;

                let input = PixelShaderInput {
                    uv: Vec2::new(u, v),
                    pixelCoord: Vec2::new(x as u32, y as u32),
                    time: 0.0,
                };
                self.put_pixel(Vec2::new(x, y), shader(input));
            }
        }
    }

    fn resize(&mut self, new_size: Extent2<usize>) {
        let mut new_pixels = vec![P::default(); new_size.w * new_size.h];
        for y in 0..new_size.h.min(self.size.h) {
            for x in 0..new_size.w.min(self.size.w) {
                new_pixels[y * new_size.w + x] =
                    self.pixels[y * self.size.w + x].clone();
            }
        }
        self.pixels = new_pixels;
        self.size = new_size;
    }
}
